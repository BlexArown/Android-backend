# Пастухов Александр Андреевич

**Группа:** ИКС-432

---

# Backend-сервер (ПР8)

Данный репозиторий создан в рамках **Практических работ №8-10** и содержит примеры клиент-серверного взаимодействия по протоколу **TCP** с использованием языков **Python**, **C** и Android-клиента (submodule).  

---

## Цель работы

- Изучить основы клиент-серверного взаимодействия
- Реализовать передачу данных по TCP
- Проверить обмен данными между программами на разных языках
- Проанализировать сетевой трафик с помощью **Wireshark**

---

## Структура репозитория
backend-server/  
├─ android-client/ # Android-приложение (submodule)  
├─ examples/  
│ ├─ server.py # TCP-сервер на Python  
│ ├─ client.py # TCP-клиент на Python  
│ ├─ server.c # TCP-сервер на C  
│ └─ client.c # TCP-клиент на C  
└─ README.md  

---

## Описание примеров

### server.py

TCP-сервер, который: слушает порт **25565**, принимает входящее соединение, получает сообщение от клиента, отправляет ответ `"Hello Client"`.  

Используемые функции: `socket()`, `bind()`, `listen()`, `accept()`, `recv()`, `send()`

---

### client.py

TCP-клиент, который: подключается к `localhost:25565`, отправляет строку `"Hello, server!"`, получает ответ от сервера, выводит полученные данные в консоль.  

---

### server.c

TCP-сервер на языке C: создаёт сокет, привязывается к порту **25565**, принимает одно соединение, получает сообщение от клиента, отправляет ответ `"Hello from c-server"`.

Используются системные вызовы Berkeley sockets: `socket`, `bind`, `listen`, `accept`, `read` ,`send`.

---

### client.c

TCP-клиент на языке C: подключается к `127.0.0.1:25565`, отправляет сообщение `"Hello from client"`, принимает ответ сервера, выводит результат в терминал.

---

## Взаимодействие между Python и C

Реализованы следующие сценарии:
- **Python client → Python server**
- **C client → Python server**
- **Python client → C server**
- **C client → C server**

Это подтверждает совместимость TCP-протокола между программами, написанными на разных языках.

---

## Анализ трафика (Wireshark)

При запуске клиента и сервера:
- в Wireshark фиксируются TCP-пакеты
- видны передаваемые строки: `"Hello, server!"`, `"Hello Client"`, `"Hello from client"`, `"Hello from c-server"`

Используется фильтр: tcp.port == 25565

---

## ПР9  
### Работа с сокетами (ZMQ). Передача данных от Android к PC

В рамках данной практической работы реализована передача данных между Android-приложением и серверным приложением на ПК с использованием библиотеки **ZeroMQ (ZMQ)**.

---

## Цель работы

- Изучить работу с сокетами ZeroMQ
- Реализовать клиент-серверное взаимодействие Android ↔ PC
- Настроить передачу данных по TCP
- Закрепить работу с потоками в Android
- Освоить работу с ветками Git и merge request

---

## Общая схема взаимодействия  

[ Android-приложение ]  
|  
| ZMQ (REQ)  
| "Hello from Android!"  
v  
[ Python-сервер (PC) ]  
|  
| ZMQ (REP)  
| "Hello from Server!"  
v  
[ Консоль + файл логов ]  

---

## Серверная часть (PC)

Серверная часть запускается на компьютере и реализована на языке **Python** с использованием ZeroMQ.

Функционал сервера:
- приём сообщений от Android-клиента;
- отправка ответного сообщения `"Hello from Server!"`;
- сохранение каждого принятого сообщения в файл;
- подсчёт количества полученных пакетов;
- вывод всех сохранённых данных в консоль.

---

## Условия выполнения

- Android-устройство и компьютер находятся в одной сети
- Сервер запускается до подключения клиента
- Передача данных инициируется нажатием кнопки в Android-приложении

---

## ПР10  
### Сериализация. Data-классы. Формирование JSON

В рамках практической работы №10 реализовано формирование структуры данных (DTO) на Android, сериализация в JSON и периодическая отправка на сервер по **ZeroMQ** (TCP). На стороне сервера данные принимаются, выводятся в консоль и сохраняются в файл.  

---

## 6.1 Схема архитектуры программного комплекса (от ПР6 до ПР10)

Начиная с получения Location (ПР6) и заканчивая передачей JSON-пакетов (ПР10):

[ Android ]  
├─ LocationActivity (ПР6) -> получение координат  
├─ TelephonyActivity (ПР7) -> получение информации о сотах (GSM/LTE/NR)  
├─ TelemetryBuilder (ПР10) -> сбор DTO -> JSON  
└─ SerializationActivity (ПР10) -> отправка JSON каждые 1s (ZMQ REQ)  
|  
| tcp://<SERVER_IP>:5555  
v  
[ Desktop Server (Python + ZMQ) ]  
├─ ZMQ REP socket -> прием JSON  
├─ вывод в консоль  
├─ счетчик пакетов  
└─ сохранение каждого пакета в файл (лог)  

---

## 6.2 Описание архитектуры клиента (Android)

### Структура проекта (файловая система)

Клиентская часть реализована в виде Android-приложения на языке Kotlin.  
Основные компоненты, задействованные в ПР10:  
app/  
├─ java/com/example/calculator/  
│ ├─ SerializationActivity.kt  
│ ├─ TelemetryBuilder.kt  
│ ├─ TelemetryDtos.kt  
│ ├─ LocationActivity.kt  
│ └─ TelephonyActivity.kt  
└─ res/layout/  
└─ activity_serialization.xml  

- `SerializationActivity.kt` — управление процессом передачи данных (Start / Stop);  
- `TelemetryBuilder.kt` — сбор данных Location и CellInfo, формирование DTO и JSON;  
- `TelemetryDtos.kt` — data-классы для сериализации;  
- `LocationActivity.kt` — получение координат устройства;  
- `TelephonyActivity.kt` — получение данных о сотовых сетях;  
- `activity_serialization.xml` — пользовательский интерфейс для запуска передачи.  

---

### Архитектура с точки зрения потоков (Thread)

В приложении используются два типа потоков:

- **UI-поток**
  - обработка нажатий кнопок;
  - отображение состояния передачи;
  - вывод информации пользователю.

- **Фоновый поток**
  - запускается при нажатии кнопки Start;
  - реализован через `Thread { sendLoop() }`;
  - с периодичностью **1 секунда**:
    - формирует структуру DTO;
    - сериализует данные в JSON;
    - отправляет данные на сервер;
    - получает ответ от сервера.

Использование фонового потока предотвращает блокировку UI.

---

### Endpoint соединения с сервером

Для передачи данных используется ZeroMQ.

- Протокол: **TCP**
- Тип сокета: **REQ**
- Endpoint сервера: tcp://<SERVER_IP>:5555

---

## 6.3 Описание архитектуры сервера (Python)

### Структура проекта (файловая система)

Серверная часть реализована на языке Python с использованием ZeroMQ.  
backend-server/  
├─ examples/  
│ └─ server_zmq.py  
└─ README.md  

- `server_zmq.py` — сервер ZeroMQ, принимающий данные от Android-клиента.

---

### Архитектура с точки зрения потоков (Thread)

Сервер реализован в виде однопоточного приложения:

- создаётся ZMQ-сокет типа **REP**;
- сервер постоянно ожидает входящие сообщения;
- при получении сообщения:
  - данные выводятся в консоль;
  - увеличивается счётчик принятых пакетов;
  - данные сохраняются в файл (лог).

---

### Endpoint’ы сервера

Сервер прослушивает входящие подключения по адресу: tcp://0.0.0.0:5555  

Используемый тип сокета:
- **REP** — сервер отвечает каждому клиентскому запросу.
